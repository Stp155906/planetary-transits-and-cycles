# -*- coding: utf-8 -*-
"""generate_weekly_transits_cycles_payload.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZQL-s68C9WNOWMrOKZKe7VQAuqWC0sRp
"""

# Weekly JSON for Transit, Synodic, Sidereal (smart units, numbers-only labels)
# - days[date][planet].{transit|synodic|sidereal} => {label, unit, index, total, meta}
# - crossing_events: [{planet, from_sign, to_sign, timestamp_utc}]
# - orbital_cycles: { planet: { sidereal_days, synodic_days } }
#
# Notes:
# • Transit + Synodic are data-driven from your ephemeris + weekly file.
# • Sidereal progress uses a mean-period approximation anchored to 2025-01-01 (flagged approximate=true).
# • Sidereal labels switch to YEARS when total_days >= 365; transit/synodic always show DAYS.
#
# You can change URLs to point at your prod feeds later.

import json, re, math
import datetime as dt
from collections import OrderedDict
from urllib.request import urlopen

EPHEMERIS_URL = "https://raw.githubusercontent.com/Stp155906/ephemeris/refs/heads/main/2025_ephemeris_with_signs.json"
WEEKLY_URL    = "https://raw.githubusercontent.com/Stp155906/weekly-view-of-retrogrades/main/weekly_forecast.json"

# ---------- constants ----------
SIGN_ORDER = ["Aries","Taurus","Gemini","Cancer","Leo","Virgo","Libra","Scorpio",
              "Sagittarius","Capricorn","Aquarius","Pisces"]
SIGN_INDEX = {s:i for i,s in enumerate(SIGN_ORDER)}
MONTH_INDEX = {
    "January":1,"February":2,"March":3,"April":4,"May":5,"June":6,
    "July":7,"August":8,"September":9,"October":10,"November":11,"December":12
}
PLANETS = ["Sun","Moon","Mercury","Venus","Mars","Jupiter","Saturn","Uranus","Neptune","Pluto"]

# Mean sidereal periods (days)
SIDEREAL = {
    "Sun": 365.256, "Moon": 27.32166, "Mercury": 87.969, "Venus": 224.701,
    "Earth": 365.256, "Mars": 686.980, "Jupiter": 4332.589, "Saturn": 10759.22,
    "Uranus": 30685.4, "Neptune": 60189.0, "Pluto": 90560.0
}

def synodic_days(body):
    # S = 1 / |1/P - 1/E|
    if body == "Moon": return 29.53059
    if body == "Sun":  return 365.242
    if body not in SIDEREAL: return None
    P, E = SIDEREAL[body], SIDEREAL["Earth"]
    return 1.0 / abs((1.0/P) - (1.0/E))

# ---------- parsing helpers ----------
def parse_sign_degree(text):
    t = (text or "").replace("’","").replace("′","").replace("`","").strip()
    m = re.match(r"([A-Za-z]+)\s+(\d{1,2})(?:\s+(\d{1,2}))?", t)
    if not m: raise ValueError(f"Unparsed position: {text}")
    sign = m.group(1).title()
    if sign.lower().startswith("sagit"): sign = "Sagittarius"
    if sign not in SIGN_INDEX: raise ValueError(f"Unknown sign: {sign}")
    d = int(m.group(2)); mins = int(m.group(3)) if m.group(3) else 0
    deg_in_sign = d + mins/60.0
    lam = (SIGN_INDEX[sign]*30.0 + deg_in_sign) % 360.0
    return sign, lam

def unwrap_delta_deg(lam1, lam2):
    # smallest signed difference in [-180, 180]
    return (lam2 - lam1 + 540.0) % 360.0 - 180.0

def boundary_lambda_for_transition(lam0, lam1):
    # choose the correct 30° boundary crossed between D and D+1 based on motion direction
    s0 = int(math.floor(lam0 / 30.0)) % 12
    dd = unwrap_delta_deg(lam0, lam1)
    if dd == 0: return None
    if dd > 0:  # prograde → next boundary
        target = ((s0 + 1) % 12) * 30.0
        if target <= lam0: target += 360.0
        if lam0 < target <= lam0 + dd: return target % 360.0
        return None
    else:       # retrograde → lower/previous boundary
        target = (s0 * 30.0) % 360.0
        if lam0 + dd <= target < lam0: return target % 360.0
        alt = ((s0 - 1) % 12) * 30.0
        if lam0 + dd <= alt < lam0: return alt % 360.0
        return None

def interpolate_crossing_time(day_date, lam0, lam1, boundary_lam):
    dd = unwrap_delta_deg(lam0, lam1)
    if dd == 0: return None
    offset = (boundary_lam - lam0)
    if dd > 0 and offset < 0: offset += 360.0
    if dd < 0 and offset > 0: offset -= 360.0
    frac = max(0.0, min(1.0, offset / dd))
    t0 = dt.datetime.combine(day_date, dt.time(0,0,0, tzinfo=dt.timezone.utc))
    return (t0 + dt.timedelta(days=frac)).isoformat().replace("+00:00","Z")

# ---------- load inputs ----------
with urlopen(WEEKLY_URL) as r: weekly = json.load(r)
with urlopen(EPHEMERIS_URL) as r: eph = json.load(r)

weekly_entries = weekly.get("weekly_forecast") or weekly.get("data") or weekly
week_dates = [dt.date.fromisoformat(x.get("date") or x.get("day")) for x in weekly_entries if (x.get("date") or x.get("day"))]
if not week_dates: raise RuntimeError("No dates found in weekly_forecast.json")
week_start, week_end = min(week_dates), max(week_dates)

# Build full 2025 map: date -> {planet: {sign, lam}}
date_map = OrderedDict()
for month_name, days in eph.items():
    m = MONTH_INDEX.get(month_name);
    if not m: continue
    for day_str, planets in (days or {}).items():
        try: d = int(day_str)
        except: continue
        try: date_obj = dt.date(2025, m, d)
        except ValueError: continue
        entry = date_map.setdefault(date_obj, {})
        for planet, pos in (planets or {}).items():
            if planet not in PLANETS: continue
            try: sign, lam = parse_sign_degree(pos)
            except: continue
            entry[planet] = {"sign": sign, "lam": lam}

all_dates = list(date_map.keys())
first_date, last_date = all_dates[0], all_dates[-1]
week_days = [d for d in all_dates if week_start <= d <= week_end]

# ---------- TRANSIT: full sign segment bounds ----------
def find_sign_segment_bounds(planet, center_date):
    if planet not in date_map.get(center_date, {}):
        return None, None, None, True
    cur_sign = date_map[center_date][planet]["sign"]
    # backward
    d = center_date
    approx = False
    while True:
        prev = d - dt.timedelta(days=1)
        if prev < first_date or planet not in date_map.get(prev, {}):
            approx = True; break
        if date_map[prev][planet]["sign"] != cur_sign:
            break
        d = prev
    start = d
    # forward
    d = center_date
    while True:
        nxt = d + dt.timedelta(days=1)
        if nxt > last_date or planet not in date_map.get(nxt, {}):
            approx = True; break
        if date_map[nxt][planet]["sign"] != cur_sign:
            break
        d = nxt
    end = d
    return start, end, cur_sign, approx

def transit_clock(planet, date_):
    s, e, sign, approx = find_sign_segment_bounds(planet, date_)
    if s is None:
        return {"label": None, "unit": "days", "index": 0, "total": 0, "meta": {"approximate": True}}
    total = (e - s).days + 1
    idx   = (date_ - s).days + 1
    return {
        "label": f"{idx}/{total} days",
        "unit": "days",
        "index": idx,
        "total": total,
        "meta": {"sign": sign, "approximate": approx}
    }

# ---------- SYNODIC: find most recent anchor (conjunction/opposition) ----------
INNER_SET  = {"Mercury","Venus","Moon"}
OUTER_SET  = {"Mars","Jupiter","Saturn","Uranus","Neptune","Pluto"}

def angsep_to_sun(planet, date_):
    lam_p = date_map[date_][planet]["lam"]
    lam_s = date_map[date_]["Sun"]["lam"]
    delta = (lam_p - lam_s) % 360.0
    return delta

def most_recent_anchor(planet, date_):
    if planet == "Sun":
        return None, None, True
    target = 0.0 if planet in INNER_SET else 180.0
    approx = False
    best_date, best_val = None, float("inf")
    last_val = None
    d = date_
    while d >= first_date:
        if planet not in date_map.get(d, {}) or "Sun" not in date_map.get(d, {}):
            approx = True
            d -= dt.timedelta(days=1)
            continue
        delta = angsep_to_sun(planet, d)
        dist = min(abs(delta - target), 360.0 - abs(delta - target))
        if dist <= best_val + 1e-6:
            best_val = dist
            best_date = d
        if last_val is not None and dist > last_val:
            break
        last_val = dist
        d -= dt.timedelta(days=1)
    return best_date, ("conjunction" if planet in INNER_SET else "opposition"), approx

def synodic_clock(planet, date_):
    S = synodic_days(planet)
    if not S:
        return {"label": None, "unit": "days", "index": 0, "total": 0, "meta": {"approximate": True}}
    anchor_date, anchor_type, approx = most_recent_anchor(planet, date_)
    if not anchor_date:
        return {"label": None, "unit": "days", "index": 0, "total": int(round(S)), "meta": {"approximate": True}}
    days_since = (date_ - anchor_date).days
    total = int(round(S))
    idx = int(max(0, min(days_since, total-1)))
    return {
        "label": f"{idx}/{total} days",
        "unit": "days",
        "index": idx,
        "total": total,
        "meta": {"anchor": anchor_type, "anchor_date": anchor_date.isoformat(), "approximate": approx}
    }

# ---------- SIDEREAL: mean progress (approx) with smart units ----------
SIDEREAL_EPOCH = dt.date(2025,1,1)  # anchor for progress counting; marked approximate=true

def sidereal_clock(planet, date_):
    P = SIDEREAL.get(planet)
    if not P:
        return {"label": None, "unit": "days", "index": 0, "total": 0, "meta": {"approximate": True}}
    # progress index as days since epoch modulo period (approximate)
    days_since_epoch = (date_ - SIDEREAL_EPOCH).days
    idx_days = int(days_since_epoch % int(round(P)))
    total_days = float(P)
    if total_days >= 365.0:
        # show years
        years_total = round(total_days / 365.2425, 1)   # e.g., 29.5
        years_idx   = round(idx_days / 365.2425, 1)     # numbers-only label
        # Avoid 0.0 showing at cycle end; keep within [0, years_total)
        years_idx = min(years_idx, max(0.0, years_total - (1.0 if years_total >= 2 else 0.1)))
        return {
            "label": f"{years_idx}/{years_total} years",
            "unit": "years",
            "index": years_idx,
            "total": years_total,
            "meta": {"total_days": total_days, "approximate": True}
        }
    else:
        # show days
        total = int(round(total_days))
        idx = min(idx_days, max(0, total-1))
        return {
            "label": f"{idx}/{total} days",
            "unit": "days",
            "index": idx,
            "total": total,
            "meta": {"total_days": total_days, "approximate": True}
        }

# ---------- crossing events within the week ----------
crossing_events = []
for i, d in enumerate(week_days[:-1]):
    d_next = week_days[i+1]
    for p in PLANETS:
        if p not in date_map.get(d, {}) or p not in date_map.get(d_next, {}):
            continue
        prev, curr = date_map[d][p], date_map[d_next][p]
        if prev["sign"] != curr["sign"]:
            lam0, lam1 = prev["lam"], curr["lam"]
            boundary = boundary_lambda_for_transition(lam0, lam1)
            ts = interpolate_crossing_time(d, lam0, lam1, boundary) if boundary is not None else None
            crossing_events.append({
                "planet": p,
                "from_sign": prev["sign"],
                "to_sign": curr["sign"],
                "timestamp_utc": ts
            })

# ---------- assemble per-day clocks ----------
days_out = OrderedDict()
for d in week_days:
    per_planet = {}
    for p in PLANETS:
        if p not in date_map.get(d, {}):
            continue
        per_planet[p] = {
            "transit":  transit_clock(p, d),
            "synodic":  synodic_clock(p, d) if p != "Sun" else {"label": None, "unit": "days", "index": 0, "total": 0, "meta": {"approximate": True}},
            "sidereal": sidereal_clock(p, d)
        }
    days_out[d.isoformat()] = per_planet

# ---------- orbital constants panel ----------
orbital_cycles = {}
for p in PLANETS:
    spec = {}
    if p in SIDEREAL:
        spec["sidereal_days"] = SIDEREAL[p]
    s = synodic_days(p)
    if s:
        spec["synodic_days"] = s
    if spec:
        orbital_cycles[p] = spec

# ---------- final payload ----------
weekly_payload = {
    "week_start": week_start.isoformat(),
    "week_end": week_end.isoformat(),
    "days": days_out,
    "crossing_events": crossing_events,
    "orbital_cycles": orbital_cycles
}

# Save to repo root so GitHub Actions can commit it
import json
with open("weekly_payload.json", "w") as f:
    json.dump(weekly_payload, f, indent=2)

print("✅ Saved weekly_payload.json")
